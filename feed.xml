<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Thomas Tan</title>
    <description>my code, info, blog.</description>
    <link>http://thomastan.github.io/</link>
    <atom:link href="http://thomastan.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 27 Mar 2015 16:07:01 -0700</pubDate>
    <lastBuildDate>Fri, 27 Mar 2015 16:07:01 -0700</lastBuildDate>
    <generator>Jekyll v3.0.0.pre.beta2</generator>
    
      <item>
        <title>Isolated Python environments %%% DRAFT %%%</title>
        <description>&lt;p&gt;You should only ever need (admin access) to globally install two Python packages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo easy_install pip
sudo pip install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first is &lt;code&gt;pip&lt;/code&gt; and this allows you to install the enabling &lt;code&gt;virtualenv&lt;/code&gt;.  With &lt;code&gt;virtualenv&lt;/code&gt;, you can have isolated Python environments, each with their own copy of &lt;code&gt;pip&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now &lt;code&gt;ch&lt;/code&gt; into the root of a project directory and run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virtualenv env
source env/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates the Python environment in &lt;code&gt;env/&lt;/code&gt; and activates the environment so the project uses env/bin/python.  Add &lt;code&gt;env/&lt;/code&gt; to .gitignore (or similar) if you’re using a version control system.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;deactivate&lt;/code&gt;, the &lt;code&gt;env/bin/deactivate&lt;/code&gt; binary will bring you back to your normal environment.&lt;/p&gt;

&lt;h4 id=&quot;requirements-files&quot;&gt;Requirements files&lt;/h4&gt;
&lt;p&gt;You can state and install dependencies in your Python environments by placing them in the &lt;code&gt;requirements.txt&lt;/code&gt; file in a project’s root directory.  These dependencies are installed with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;env/bin/pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Have fun installing as many Python packages as you’d like without polluting your systems!&lt;/p&gt;
</description>
        <pubDate>Wed, 31 Dec 2014 00:00:00 -0700</pubDate>
        <link>http://thomastan.github.io/post/isolated-python-environments</link>
        <guid isPermaLink="true">http://thomastan.github.io/post/isolated-python-environments</guid>
        
        <category>code</category>
        
        <category>python</category>
        
        <category>isolation</category>
        
        <category>virtual-machine</category>
        
        <category>virtualenv</category>
        
        <category>pip</category>
        
        
        <category>post</category>
        
      </item>
    
      <item>
        <title>Isolated Python environments %%% DRAFT %%%</title>
        <description>&lt;p&gt;A polynomial of degree $n$, $P_n(x) = a_n x^n + a_{n-1} x^{n-1} + a_{n-2} x^{n-2} + \ldots + a_0$ can be represented in C as the vector &lt;code&gt;{ a[0], a[1], ..., a[n] }&lt;/code&gt;.  The vector has size $n+1$. &lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Such a polynomial can be differentiated with a C function operating on the polynomial’s coëfficient vector (here called &lt;code&gt;coeff&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;

void differentiate(float *coeff, int degree) {
    int i;
    for (i = 0; i &amp;lt;= degree - 1; i++)
        coeff[i] = (i + 1) * coeff[i + 1];

    if (degree &amp;gt;= 1) {
        // The polynomial and its coëfficient vector has a new size
        coeff = (float *) realloc(coeff, degree * sizeof(float));

        degree--;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 31 Dec 2014 00:00:00 -0700</pubDate>
        <link>http://thomastan.github.io/post/draft-test</link>
        <guid isPermaLink="true">http://thomastan.github.io/post/draft-test</guid>
        
        <category>code</category>
        
        <category>python</category>
        
        <category>isolation</category>
        
        <category>virtual-machine</category>
        
        <category>virtualenv</category>
        
        <category>pip</category>
        
        
        <category>post</category>
        
      </item>
    
      <item>
        <title>Quickly test for a &quot;power of two&quot;</title>
        <description>&lt;p&gt;For positive integers $k$, use just two to three lines:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;C/C++:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;#include &amp;lt;stdbool.h&amp;gt; // not needed in C++

bool fromDoubling(unsigned k) {
    return !((k - 1) &amp;amp; k) &amp;amp;&amp;amp; k;
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;def fromDoubling(k):
    return not((k - 1) &amp;amp; k) and k
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Perl:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;use boolean;

sub fromDoubling {
    sprintf(&quot;%b&quot;, shift) =~ /^10*$/ ? true : false;
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 26 Oct 2013 00:00:00 -0700</pubDate>
        <link>http://thomastan.github.io/post/power-of-two</link>
        <guid isPermaLink="true">http://thomastan.github.io/post/power-of-two</guid>
        
        <category>code</category>
        
        <category>simple</category>
        
        <category>c</category>
        
        <category>perl</category>
        
        <category>python</category>
        
        <category>kiss</category>
        
        <category>power</category>
        
        <category>bitwise</category>
        
        
        <category>post</category>
        
      </item>
    
      <item>
        <title>The min and max functions</title>
        <description>&lt;p&gt;Most people naïvely implement the maximum function using five lines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int max(int a, int b) {
    if (a &amp;gt; b)
        return a;
    else
        return b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More elegantly, the “if” and “else” conditions can be replaced by the question mark operator &lt;code&gt;?:&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maximum = a &amp;gt; b ? a : b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oftentimes, all three of “if”, “else” and “?:” are unavailable to use (such as in low-level hardware design) or are just a pain to implement because of the jumping around involved (when writing things in assembly, per se).  In these cases, an easy way to find the maximum is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a - ((a - b) &amp;amp; -(a &amp;lt; b));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A sign change in each of the above implementations will give the minimum.&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Oct 2013 00:00:00 -0700</pubDate>
        <link>http://thomastan.github.io/post/min-and-max-functions</link>
        <guid isPermaLink="true">http://thomastan.github.io/post/min-and-max-functions</guid>
        
        <category>math</category>
        
        <category>code</category>
        
        <category>c</category>
        
        <category>simple</category>
        
        <category>hardware</category>
        
        <category>assembly</category>
        
        <category>bitwise</category>
        
        <category>logic</category>
        
        <category>kiss</category>
        
        <category>max</category>
        
        <category>min</category>
        
        
        <category>post</category>
        
      </item>
    
      <item>
        <title>A 20-year old binary search mistake</title>
        <description>&lt;p&gt;Binary searching for a certain “key” within a sorted list involves looking at the “middle” element, then, if the key isn’t found, looking through either the first or second half of the list.  The binary searching process is repeated on the sublist.&lt;/p&gt;

&lt;p&gt;The following implementation, previously used almost everywhere, had a mistake that evaded detection for 20 years:&lt;/p&gt;

&lt;!--more--&gt;

&lt;pre&gt;&lt;code&gt;int binarySearch(int a[], int length, int key) {
    int start = 0, middle, end = length - 1;

    while (start &amp;lt;= end) {
        middle = (start + end) / 2;

        if (a[middle] == key)
            return middle;
        else if (key &amp;gt; a[middle])
            start = middle + 1;
        else if (key &amp;lt; a[middle])
            end = middle - 1;
    }

    return -1;  /* the key wasn&#39;t found */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is in the calculation of &lt;code&gt;middle&lt;/code&gt; for certain sublists.  For sublists closer toward the right of the original list there is a chance of &lt;code&gt;(start + end)&lt;/code&gt; overflowing. The fix is to restrict calculation of &lt;code&gt;middle&lt;/code&gt; from going above &lt;code&gt;length&lt;/code&gt;, done by replacing&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;middle = (start + end) / 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;middle = start + (end - start) / 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;middle&lt;/code&gt;, along with the intermediate calculation of it, is guaranteed to always be less than &lt;code&gt;length&lt;/code&gt;.  The use of a &lt;code&gt;middle&lt;/code&gt; to iteratively split the list in half means the complexity of binary search is $\mathcal{O}(\log_2 n)$.&lt;/p&gt;
</description>
        <pubDate>Thu, 26 Sep 2013 00:00:00 -0700</pubDate>
        <link>http://thomastan.github.io/post/binary-search-mistake</link>
        <guid isPermaLink="true">http://thomastan.github.io/post/binary-search-mistake</guid>
        
        <category>code</category>
        
        <category>c</category>
        
        <category>mistakes</category>
        
        <category>max</category>
        
        <category>overflow</category>
        
        <category>recursion</category>
        
        <category>searching</category>
        
        
        <category>post</category>
        
      </item>
    
      <item>
        <title>Swapping numbers without a temporary variable</title>
        <description>&lt;p&gt;Most people do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int temp;
temp = a, a = b, b = temp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;when you can do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a ^= b ^= a ^= b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember, &lt;a href=&quot;../tag/kiss&quot;&gt;KISS&lt;/a&gt; — keep it &lt;a href=&quot;writing-simple-code&quot;&gt;simple&lt;/a&gt;, stupid!&lt;/p&gt;
</description>
        <pubDate>Sat, 14 Sep 2013 00:00:00 -0700</pubDate>
        <link>http://thomastan.github.io/post/swapping-without-temp</link>
        <guid isPermaLink="true">http://thomastan.github.io/post/swapping-without-temp</guid>
        
        <category>code</category>
        
        <category>simple</category>
        
        <category>c</category>
        
        <category>kiss</category>
        
        <category>xor</category>
        
        <category>bitwise</category>
        
        
        <category>post</category>
        
      </item>
    
      <item>
        <title>How operators save lines</title>
        <description>&lt;p&gt;Operators such as the &lt;em&gt;coälescing&lt;/em&gt; (or &lt;em&gt;null-coälescing&lt;/em&gt;) operator in Microsoft’s C# language are capable of saving you from unnecessary lines of code when writing if-then-else assignment code blocks.  In C# the operator is &lt;code&gt;??&lt;/code&gt; and it’s also called the “double question mark” operator, but, unlike the ternary “single question mark operator” &lt;code&gt;?:&lt;/code&gt;, &lt;code&gt;??&lt;/code&gt; only takes two operands; a value to be assigned provided it isn’t &lt;em&gt;null&lt;/em&gt;, and an alternative for when it is.&lt;/p&gt;

&lt;p&gt;An example in C#:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;

class Cafeteria {
    static void Main(string[] args) {
        serve(null);
    }

    static void serve(string requested) {
        string toServe = requested ?? &quot;French Fries&quot;;
        Console.WriteLine(toServe);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;p&gt;Perl 5.10+ also provides for null-coälescing via &lt;code&gt;//&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env perl

$toServe = $requested // &quot;French Fries&quot;;
print $toServe;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code containing null-coälescing operators have equivalents in their same language and in others, written using &lt;code&gt;?:&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt; or if-then-else statements.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Take the ternary &lt;code&gt;?:&lt;/code&gt; operator for example:
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;string toServe = requested ?? &quot;French Fries&quot;;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;string toServe = requested ? requested : &quot;French Fries&quot;;&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;Now comes your first warning: the above two code fragments are only equivalent in C# for the &lt;code&gt;requested == null&lt;/code&gt; case.  If &lt;code&gt;requested&lt;/code&gt; is the empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;, the first line with &lt;code&gt;??&lt;/code&gt; works as expected, but the second won’t as am empty string is not boolean false.&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;  However, it can be adjusted so it works as expected:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;In C#:&lt;br /&gt;
&lt;code&gt;string toServe = requested.Length &amp;gt; 0 ? requested : &quot;French Fries&quot;;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;In C++:&lt;br /&gt;
&lt;code&gt;string toServe = requested.length() &amp;gt; 0? requested : &quot;French Fries&quot;;&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In many languages the logical “OR” operator suffices.  In JavaScript for example, “OR” is &lt;code&gt;||&lt;/code&gt;:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;function serve(requested) {
    var toServe = (requested || &quot;French Fries&quot;);
    alert(toServe);
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;code&gt;serve()&lt;/code&gt; yields “&lt;code&gt;French Fries&lt;/code&gt;” and &lt;code&gt;serve(&quot;meat&quot;)&lt;/code&gt; yields “&lt;code&gt;meat&lt;/code&gt;”.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If you want to replace an if-then-else block with a null-coälescing operator you’ll need to exercise a bit of caution.  The following cannot be converted to use a null-coälescing operator:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;if (winnings)
    gain = winnings;
else
    spent += 1;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;Why not?  Because the conditional assignment is done to two differing variables, depending on whether &lt;code&gt;winnings&lt;/code&gt; is defined or not.  You also cannot convert the above to use the &lt;code&gt;?:&lt;/code&gt; operator in this case.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In conclusion, the null-coälescing “double-question mark” operator is awesome.  For languages without it, you can still use &lt;code&gt;?:&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; to shorten code, but you need to pay attention when conditioning on your left operand depending on whether or not your language differentiates 0, empty strings and unassigned variables from &lt;em&gt;null&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;C# error: “Cannot implicitly convert type ‘string’ to ‘bool’”. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;C++ error: “could not convert ‘requested’ from ‘std::string {aka std::basic_string&lt;char&gt;}&#39; to &#39;bool&#39;&quot;.&lt;/char&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 24 Aug 2013 00:00:00 -0700</pubDate>
        <link>http://thomastan.github.io/post/operators-save-lines</link>
        <guid isPermaLink="true">http://thomastan.github.io/post/operators-save-lines</guid>
        
        <category>code</category>
        
        <category>C-sharp</category>
        
        <category>JavaScript</category>
        
        <category>Perl</category>
        
        <category>question-mark</category>
        
        <category>null-coalescing</category>
        
        <category>operator</category>
        
        <category>KISS</category>
        
        <category>simple</category>
        
        
        <category>post</category>
        
      </item>
    
      <item>
        <title>Writing simple code</title>
        <description>&lt;meta lang=&quot;en&quot; translation=&quot;fr-CA&quot; title=&quot;L&#39;écriture de code simple&quot; /&gt;

&lt;p&gt;Complicated code is easy to write.  Simple code is hard to write.  How so?  Because “complicated” in this case doesn’t mean “complex” code, it means code that’s made unnecessarily complicated; obfuscated and harder to read and harder to understand.&lt;/p&gt;

&lt;p&gt;Below are two examples; one calculates the factorial $n!$, the other finds the greatest common divisor (GCD).  Both examples are done in a single line and show how things can be kept minimalistic. &lt;!--more--&gt;&lt;/p&gt;

&lt;h4 id=&quot;factorial&quot;&gt;Factorial&lt;/h4&gt;
&lt;p&gt;The factorial of a non-negative integer $n$ is denoted $n!$.  Mathematically,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
n! = \begin{cases} 1 &amp; n = 0 \newline \prod_{k=1}^{n} k &amp; n \in \mathbb{Z^+} \end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;In C/C++:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int factorial(int n) {
	return n == 0 || n == 1 ? 1 : n * factorial(n - 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;euclids-algorithm&quot;&gt;Euclid’s algorithm&lt;/h4&gt;
&lt;p&gt;Euclid’s algorithm computes the &lt;em&gt;greatest common divisor&lt;/em&gt; (GCD) of two integers $a$ and $b$.  The GCD does not change if the smaller number is subtracted from the larger.  By repeating this process, smaller pairs of integers can be successively obtained until a pair of equal integers, or integers with unit difference is obtained.  By using modular arithmetic in place of subtractions, the process can be further accelerated.  Mathematically,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\gcd(a,b) = \begin{cases} a &amp; \text{if}~b = 0 \newline \gcd\left(b, a - b \left\lfloor {a \over b} \right\rfloor\right) &amp; \text{otherwise} \end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;So how can this be performed in code?  Here’s how in C/C++:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a % b);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember, always KISS — keep it simple, stupid!&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Aug 2013 00:00:00 -0700</pubDate>
        <link>http://thomastan.github.io/post/simple-code</link>
        <guid isPermaLink="true">http://thomastan.github.io/post/simple-code</guid>
        
        <category>code</category>
        
        <category>c</category>
        
        <category>c++</category>
        
        <category>simple</category>
        
        <category>math</category>
        
        <category>factorial</category>
        
        <category>gcd</category>
        
        <category>euclid</category>
        
        <category>recursion</category>
        
        
        <category>post</category>
        
      </item>
    
      <item>
        <title>Factorial and nCr() in Scheme</title>
        <description>&lt;p&gt;Recursive form, starting with $n!$:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define factorial
    (lambda (n)
        (if (or (= n 0) (= n 1))
            1
            (* n (factorial (- n 1)))
)    )    )
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;p&gt;nCr using $\displaystyle{ {n \choose r} = {n! \over r!(n-r)!} }$:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define ncr
    (lambda (n r)
        (/ (factorial n) (* (factorial r) (factorial (- n r))))
)    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and a safer version of nCr:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define ncr
    (lambda (n r)
        (if (or (= n r) (= r 0))
            1
            (+ (ncr (- n 1) (- r 1)) (ncr (- n 1) r))
)    )    )
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 03 Aug 2013 00:00:00 -0700</pubDate>
        <link>http://thomastan.github.io/post/functions-in-scheme</link>
        <guid isPermaLink="true">http://thomastan.github.io/post/functions-in-scheme</guid>
        
        <category>math</category>
        
        <category>code</category>
        
        <category>scheme</category>
        
        <category>factorial</category>
        
        <category>ncr</category>
        
        <category>recursive</category>
        
        <category>recursion</category>
        
        
        <category>post</category>
        
      </item>
    
      <item>
        <title>Don&#39;t screw up nCr()</title>
        <description>&lt;p&gt;You will screw up if you try to implement &lt;code&gt;nCr(int n, int r)&lt;/code&gt; using
&lt;script type=&quot;math/tex&quot;&gt;{n\choose r} = {n! \over r! (n - r)!}.&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Here’s why: $n!$ will overflow! &lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;What you need to do is use the recursive formula&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{n \choose r} = {n-1 \choose r-1} + {n-1 \choose r} \qquad \forall \{n,r\in\mathbb{Z} \mid 1 \le r \le n-1 \}.&lt;/script&gt;

&lt;p&gt;With the base cases $\displaystyle{r\choose r}$, $\displaystyle{r\choose0} = 1$ we have
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
{n \choose r}=\begin{cases}
1 &amp; \text{if}\ {k \choose k}\ \text{or}\ {k \choose 0}, \{k\in\mathbb{Z}\}\newline
{n-1 \choose r-1}+{n-1 \choose r} &amp; \forall \{n,r\in\mathbb{Z}\mid1\le r\le n-1\}
\end{cases} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;In C:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int nCr(int n, int r) {
    if (n == r || r == 0)
        return 1;
    else
        return nCr(n - 1, r - 1) + nCr(n - 1, r);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will protect you (not entirely) from overflow. The complexity is $\mathcal{O}(n^2)$.&lt;/p&gt;
</description>
        <pubDate>Fri, 02 Aug 2013 00:00:00 -0700</pubDate>
        <link>http://thomastan.github.io/post/dont-screw-up-ncr</link>
        <guid isPermaLink="true">http://thomastan.github.io/post/dont-screw-up-ncr</guid>
        
        <category>math</category>
        
        <category>code</category>
        
        <category>c</category>
        
        <category>probability</category>
        
        <category>overflow</category>
        
        <category>nCr</category>
        
        <category>factorial</category>
        
        
        <category>post</category>
        
      </item>
    
  </channel>
</rss>
